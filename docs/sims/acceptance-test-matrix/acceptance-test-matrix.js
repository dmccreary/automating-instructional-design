/**
 * Acceptance Test Matrix MicroSim
 * Interactive matrix for tracking MicroSim acceptance criteria across
 * functional, pedagogical, technical, and assessment dimensions.
 *
 * Features:
 * - Click to cycle test status: untested -> pass -> fail -> untested
 * - localStorage persistence
 * - Markdown export
 * - Real-time score calculation
 * - Full keyboard accessibility
 */

(function() {
    'use strict';

    // Test data loaded from external JSON
    let testData = null;

    // State management
    const STORAGE_KEY = 'acceptance-test-matrix-state';
    let state = {};

    /**
     * Load test data from external JSON file
     */
    async function loadTestData() {
        try {
            const response = await fetch('data.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            testData = await response.json();
            return true;
        } catch (e) {
            console.error('Could not load test data:', e);
            return false;
        }
    }

    /**
     * Load state from localStorage or initialize empty state
     */
    function loadState() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                return JSON.parse(saved);
            }
        } catch (e) {
            console.warn('Could not load saved state:', e);
        }
        return initializeState();
    }

    /**
     * Initialize empty state object
     */
    function initializeState() {
        const newState = {};
        if (testData) {
            Object.values(testData).forEach(category => {
                category.tests.forEach(test => {
                    newState[test.id] = 'untested'; // untested, pass, fail
                });
            });
        }
        return newState;
    }

    /**
     * Save state to localStorage
     */
    function saveState() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            console.warn('Could not save state:', e);
        }
    }

    /**
     * Cycle test status: untested -> pass -> fail -> untested
     */
    function cycleStatus(testId) {
        const current = state[testId];
        if (current === 'untested') {
            state[testId] = 'pass';
        } else if (current === 'pass') {
            state[testId] = 'fail';
        } else {
            state[testId] = 'untested';
        }
        saveState();
        render();
    }

    /**
     * Reset all tests to untested
     */
    function resetAll() {
        state = initializeState();
        saveState();
        render();
    }

    /**
     * Mark all tests as passed
     */
    function passAll() {
        Object.keys(state).forEach(key => {
            state[key] = 'pass';
        });
        saveState();
        render();
    }

    /**
     * Calculate scores for display
     */
    function calculateScores() {
        const scores = {
            overall: { total: 0, passed: 0, failed: 0 },
            categories: {}
        };

        Object.entries(testData).forEach(([categoryKey, category]) => {
            const categoryScore = { total: 0, passed: 0, failed: 0 };
            category.tests.forEach(test => {
                categoryScore.total++;
                scores.overall.total++;
                if (state[test.id] === 'pass') {
                    categoryScore.passed++;
                    scores.overall.passed++;
                } else if (state[test.id] === 'fail') {
                    categoryScore.failed++;
                    scores.overall.failed++;
                }
            });
            scores.categories[categoryKey] = categoryScore;
        });

        return scores;
    }

    /**
     * Generate markdown export of current state
     */
    function generateMarkdown() {
        const scores = calculateScores();
        const overallPercent = Math.round((scores.overall.passed / scores.overall.total) * 100);

        let md = `# MicroSim Acceptance Test Results\n\n`;
        md += `**Date:** ${new Date().toLocaleDateString()}\n`;
        md += `**Overall Coverage:** ${overallPercent}% (${scores.overall.passed}/${scores.overall.total} passed)\n\n`;

        Object.entries(testData).forEach(([categoryKey, category]) => {
            const catScore = scores.categories[categoryKey];
            const catPercent = Math.round((catScore.passed / catScore.total) * 100);

            md += `## ${category.name} (${catPercent}%)\n\n`;

            category.tests.forEach(test => {
                const status = state[test.id];
                let checkbox = '[ ]';
                if (status === 'pass') checkbox = '[x]';
                else if (status === 'fail') checkbox = '[-]';

                md += `- ${checkbox} ${test.name}\n`;
            });
            md += '\n';
        });

        md += `---\n`;
        md += `*Generated by Acceptance Test Matrix MicroSim*\n`;

        return md;
    }

    /**
     * Escape HTML entities for safe rendering
     */
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Render the entire UI
     */
    function render() {
        const grid = document.getElementById('matrixGrid');
        const scores = calculateScores();

        // Update overall score display
        const overallPercent = Math.round((scores.overall.passed / scores.overall.total) * 100);
        document.getElementById('overallScore').textContent = overallPercent + '%';

        const progressBar = document.getElementById('progressBar');
        progressBar.style.width = overallPercent + '%';
        progressBar.parentElement.setAttribute('aria-valuenow', overallPercent);

        // Update progress bar color based on score
        if (overallPercent >= 80) {
            progressBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
        } else if (overallPercent >= 50) {
            progressBar.style.background = 'linear-gradient(90deg, #FF9800, #FFC107)';
        } else {
            progressBar.style.background = 'linear-gradient(90deg, #f44336, #FF5722)';
        }

        // Render category columns
        grid.innerHTML = '';

        Object.entries(testData).forEach(([categoryKey, category]) => {
            const catScore = scores.categories[categoryKey];
            const catPercent = Math.round((catScore.passed / catScore.total) * 100);

            const categoryDiv = document.createElement('div');
            categoryDiv.className = `category category-${categoryKey}`;
            categoryDiv.setAttribute('role', 'region');
            categoryDiv.setAttribute('aria-label', `${category.name} tests`);

            categoryDiv.innerHTML = `
                <div class="category-header">
                    <span class="category-title">${escapeHtml(category.name)}</span>
                    <span class="category-percent">${catPercent}%</span>
                </div>
                <div class="test-items" role="list">
                </div>
            `;

            const testItemsContainer = categoryDiv.querySelector('.test-items');

            category.tests.forEach(test => {
                const status = state[test.id];
                const testItem = document.createElement('div');
                testItem.className = `test-item ${status === 'pass' ? 'passed' : ''} ${status === 'fail' ? 'failed' : ''}`;
                testItem.setAttribute('role', 'listitem');
                testItem.setAttribute('tabindex', '0');
                testItem.setAttribute('aria-label', `${test.name}: ${status}`);
                testItem.dataset.testId = test.id;

                let checkIcon = '';
                if (status === 'pass') checkIcon = '&#10003;';
                else if (status === 'fail') checkIcon = '&#10005;';

                let statusClass = 'status-untested';
                let statusText = 'Untested';
                if (status === 'pass') {
                    statusClass = 'status-pass';
                    statusText = 'Pass';
                } else if (status === 'fail') {
                    statusClass = 'status-fail';
                    statusText = 'Fail';
                }

                testItem.innerHTML = `
                    <div class="test-checkbox" aria-hidden="true">${checkIcon}</div>
                    <div class="test-content">
                        <div class="test-name">${escapeHtml(test.name)}</div>
                        <div class="test-description">${escapeHtml(test.description)}</div>
                    </div>
                    <span class="status-indicator ${statusClass}">${statusText}</span>
                `;

                testItem.addEventListener('click', () => cycleStatus(test.id));
                testItem.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        cycleStatus(test.id);
                    }
                });

                testItemsContainer.appendChild(testItem);
            });

            grid.appendChild(categoryDiv);
        });
    }

    /**
     * Show export modal
     */
    function showExportModal() {
        const modal = document.getElementById('exportModal');
        const textarea = document.getElementById('exportTextarea');
        textarea.value = generateMarkdown();
        modal.classList.add('active');
        textarea.focus();
    }

    /**
     * Hide export modal
     */
    function hideExportModal() {
        const modal = document.getElementById('exportModal');
        modal.classList.remove('active');
        document.getElementById('exportBtn').focus();
    }

    /**
     * Copy export content to clipboard
     */
    function copyToClipboard() {
        const textarea = document.getElementById('exportTextarea');
        textarea.select();
        document.execCommand('copy');

        const copyBtn = document.getElementById('copyBtn');
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
            copyBtn.textContent = originalText;
        }, 2000);
    }

    /**
     * Initialize event listeners and render
     */
    async function init() {
        // Load test data first
        const loaded = await loadTestData();
        if (!loaded) {
            document.getElementById('matrixGrid').innerHTML =
                '<p style="color: red; padding: 20px;">Error: Could not load test data. Please refresh the page.</p>';
            return;
        }

        // Load state after test data is available
        state = loadState();

        // Button event listeners
        document.getElementById('resetBtn').addEventListener('click', resetAll);
        document.getElementById('passAllBtn').addEventListener('click', passAll);
        document.getElementById('exportBtn').addEventListener('click', showExportModal);
        document.getElementById('modalClose').addEventListener('click', hideExportModal);
        document.getElementById('copyBtn').addEventListener('click', copyToClipboard);

        // Close modal on background click
        document.getElementById('exportModal').addEventListener('click', (e) => {
            if (e.target.id === 'exportModal') {
                hideExportModal();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('exportModal');
                if (modal.classList.contains('active')) {
                    hideExportModal();
                }
            }
        });

        // Initial render
        render();
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
